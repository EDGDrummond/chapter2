{"message":"unused `#[macro_use]` import","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":242,"byte_end":254,"line_start":8,"line_end":8,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[macro_use]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused `#[macro_use]` import\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:8:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m#[macro_use]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"`main` function not found in crate `rustymachine_regression`","code":{"code":"E0601","explanation":"No `main` function was found in a binary crate.\n\nTo fix this error, add a `main` function:\n\n```\nfn main() {\n    // Your program will start here.\n    println!(\"Hello world!\");\n}\n```\n\nIf you don't know the basics of Rust, you can look at the\n[Rust Book][rust-book] to get started.\n\n[rust-book]: https://doc.rust-lang.org/book/\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":222,"byte_end":3492,"line_start":7,"line_end":97,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"extern crate serde;","highlight_start":1,"highlight_end":20},{"text":"#[macro_use]","highlight_start":1,"highlight_end":13},{"text":"extern crate serde_derive;","highlight_start":1,"highlight_end":27},{"text":"use std::io::prelude::*;","highlight_start":1,"highlight_end":25},{"text":"use std::io::BufReader;","highlight_start":1,"highlight_end":24},{"text":"use std::path::Path;","highlight_start":1,"highlight_end":21},{"text":"use std::fs::File;","highlight_start":1,"highlight_end":19},{"text":"use std::vec::Vec;","highlight_start":1,"highlight_end":19},{"text":"use std::error::Error;","highlight_start":1,"highlight_end":23},{"text":"use rand::thread_rng;","highlight_start":1,"highlight_end":22},{"text":"use rand::seq::SliceRandom;","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// A struct to contain all the info of a house in the Boston Housing data. ","highlight_start":1,"highlight_end":76},{"text":"pub struct BostonHousing {","highlight_start":1,"highlight_end":27},{"text":"    crim: f64, zn: f64, indus: f64, chas: f64, nox: f64, rm: f64, age: f64, ","highlight_start":1,"highlight_end":77},{"text":"    dis: f64, rad: f64, tax: f64, ptratio: f64, black: f64, lstat: f64, medv: f64, ","highlight_start":1,"highlight_end":84},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl BostonHousing {","highlight_start":1,"highlight_end":21},{"text":"    pub fn new(v: Vec<&str>) -> Self {","highlight_start":1,"highlight_end":39},{"text":"        let f64_formatted: Vec<f64> = v.iter()","highlight_start":1,"highlight_end":47},{"text":"                                        .map(|s| s.parse().unwrap())","highlight_start":1,"highlight_end":69},{"text":"                                        .collect();","highlight_start":1,"highlight_end":52},{"text":"        BostonHousing {","highlight_start":1,"highlight_end":24},{"text":"            crim: f64_formatted[0], zn: f64_formatted[1], ","highlight_start":1,"highlight_end":59},{"text":"            indus: f64_formatted[2], chas: f64_formatted[3], ","highlight_start":1,"highlight_end":62},{"text":"            nox: f64_formatted[4], rm: f64_formatted[5], ","highlight_start":1,"highlight_end":58},{"text":"            age: f64_formatted[6], dis: f64_formatted[7], ","highlight_start":1,"highlight_end":59},{"text":"            rad: f64_formatted[8], tax: f64_formatted[9], ","highlight_start":1,"highlight_end":59},{"text":"            ptratio: f64_formatted[10], black: f64_formatted[11], ","highlight_start":1,"highlight_end":67},{"text":"            lstat: f64_formatted[12], medv: f64_formatted[13],","highlight_start":1,"highlight_end":63},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn into_feature_vector(&self) -> Vec<f64> {","highlight_start":1,"highlight_end":52},{"text":"        vec![self.crim, self.zn, self.indus, self.chas, self.nox,","highlight_start":1,"highlight_end":66},{"text":"        self.rm, self.age, self.dis, self.rad, self.tax, self.ptratio,","highlight_start":1,"highlight_end":71},{"text":"        self.black, self.lstat]","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn into_targets(&self) -> f64 {","highlight_start":1,"highlight_end":40},{"text":"        self.medv","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn get_boston_record(s: String) -> BostonHousing {","highlight_start":1,"highlight_end":51},{"text":"    let v: Vec<&str> = s.split_whitespace().collect();","highlight_start":1,"highlight_end":55},{"text":"    let b: BostonHousing = BostonHousing::new(v);","highlight_start":1,"highlight_end":50},{"text":"    b","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn get_boston_records_from_file( fl: impl AsRef<Path> ) -> Vec<BostonHousing> {","highlight_start":1,"highlight_end":80},{"text":"    let file = File::open(fl).expect(\"no such file\");","highlight_start":1,"highlight_end":54},{"text":"    let buf = BufReader::new(file);","highlight_start":1,"highlight_end":36},{"text":"    buf.lines()","highlight_start":1,"highlight_end":16},{"text":"        .enumerate()","highlight_start":1,"highlight_end":21},{"text":"        .map(|n,l| l.expect(&format!(\"Could not parse line no {}\", n)))","highlight_start":1,"highlight_end":72},{"text":"        .map(|r| get_boston_record(r))","highlight_start":1,"highlight_end":39},{"text":"        .collect()","highlight_start":1,"highlight_end":19},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"pub fn run() -> Result<(), Box<dyn Error>> {","highlight_start":1,"highlight_end":45},{"text":"    let fl = \"data/housing.csv\";","highlight_start":1,"highlight_end":33},{"text":"    let mut data = get_boston_records_from_file(&fl);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    data.shuffle(&mut thread_rng());","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Separate out to train and test datasets.","highlight_start":1,"highlight_end":48},{"text":"    let mut test_size: f64 = 0.2;","highlight_start":1,"highlight_end":34},{"text":"    test_size = data.len() as f64 * test_size;","highlight_start":1,"highlight_end":47},{"text":"    let test_size = test_size.round() as usize;","highlight_start":1,"highlight_end":48},{"text":"    let (test_data, train_data) = data.split_at(test_size);","highlight_start":1,"highlight_end":60},{"text":"    let train_size = train_data.len();","highlight_start":1,"highlight_end":39},{"text":"    let test_size = test_data.len();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Differentiate the predictors and the targets.","highlight_start":1,"highlight_end":53},{"text":"    let boston_x_train: Vec<f64> = train_data.iter()","highlight_start":1,"highlight_end":53},{"text":"                                             .map(|r| r.into_targets())","highlight_start":1,"highlight_end":72},{"text":"                                             .collect();","highlight_start":1,"highlight_end":57},{"text":"    let boston_y_train: Vec<f64> = train_data.iter()","highlight_start":1,"highlight_end":53},{"text":"                                             .map(|r| r.into_targets())","highlight_start":1,"highlight_end":72},{"text":"                                             .collect();","highlight_start":1,"highlight_end":57},{"text":"    let boston_x_test: Vec<f64> = test_data.iter()","highlight_start":1,"highlight_end":51},{"text":"                                             .map(|r| r.into_targets())","highlight_start":1,"highlight_end":72},{"text":"                                             .collect();","highlight_start":1,"highlight_end":57},{"text":"    let boston_y_test: Vec<f64> = test_data.iter()","highlight_start":1,"highlight_end":51},{"text":"                                             .map(|r| r.into_targets())","highlight_start":1,"highlight_end":72},{"text":"                                             .collect();","highlight_start":1,"highlight_end":57},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"consider adding a `main` function to `src\\main.rs`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0601]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `main` function not found in crate `rustymachine_regression`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:7:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m7\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern crate serde;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[macro_use]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mextern crate serde_derive;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::io::prelude::*;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                             .collect();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m97\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider adding a `main` function to `src\\main.rs`\u001b[0m\n\n"}
{"message":"closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments","code":{"code":"E0593","explanation":"You tried to supply an `Fn`-based type with an incorrect number of arguments\nthan what was expected.\n\nErroneous code example:\n\n```compile_fail,E0593\nfn foo<F: Fn()>(x: F) { }\n\nfn main() {\n    // [E0593] closure takes 1 argument but 0 arguments are required\n    foo(|y| { });\n}\n```\n\nYou have to provide the same number of arguments as expected by the `Fn`-based\ntype. So to fix the previous example, we need to remove the `y` argument:\n\n```\nfn foo<F: Fn()>(x: F) { }\n\nfn main() {\n    foo(|| { }); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":2103,"byte_end":2106,"line_start":63,"line_end":63,"column_start":10,"column_end":13,"is_primary":true,"text":[{"text":"        .map(|n,l| l.expect(&format!(\"Could not parse line no {}\", n)))","highlight_start":10,"highlight_end":13}],"label":"expected closure that takes a single 2-tuple as argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":2107,"byte_end":2112,"line_start":63,"line_end":63,"column_start":14,"column_end":19,"is_primary":false,"text":[{"text":"        .map(|n,l| l.expect(&format!(\"Could not parse line no {}\", n)))","highlight_start":14,"highlight_end":19}],"label":"takes 2 distinct arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"change the closure to accept a tuple instead of individual arguments","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":2107,"byte_end":2112,"line_start":63,"line_end":63,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"        .map(|n,l| l.expect(&format!(\"Could not parse line no {}\", n)))","highlight_start":14,"highlight_end":19}],"label":null,"suggested_replacement":"|(n, l)|","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0593]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:63:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        .map(|n,l| l.expect(&format!(\"Could not parse line no {}\", n)))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mtakes 2 distinct arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected closure that takes a single 2-tuple as argument\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: change the closure to accept a tuple instead of individual arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        .map(|(n, l)| l.expect(&format!(\"Could not parse line no {}\", n)))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":2245,"byte_end":2271,"line_start":70,"line_end":70,"column_start":17,"column_end":43,"is_primary":true,"text":[{"text":"pub fn run() -> Result<(), Box<dyn Error>> {","highlight_start":17,"highlight_end":43}],"label":"expected enum `std::result::Result`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":2236,"byte_end":2239,"line_start":70,"line_end":70,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn run() -> Result<(), Box<dyn Error>> {","highlight_start":8,"highlight_end":11}],"label":"implicitly returns `()` as its body has no tail or `return` expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `std::result::Result<(), Box<(dyn StdError + 'static)>>`\nfound unit type `()`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:70:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m70\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mpub fn run() -> Result<(), Box<dyn Error>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected enum `std::result::Result`, found `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimplicitly returns `()` as its body has no tail or `return` expression\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m:   expected enum `\u001b[0m\u001b[0m\u001b[1mstd::result::Result<(), Box<(dyn StdError + 'static)>>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m           found unit type `\u001b[0m\u001b[0m\u001b[1m()\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 3 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0308, E0593, E0601.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0308, E0593, E0601.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0308`.\u001b[0m\n"}
